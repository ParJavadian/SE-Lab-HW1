# SE-Lab-HW1

این تمرین با هدف آموزش و تمرین مفاهیم مهندسی نرم‌افزار، به ویژه در زمینه کار گروهی و مدیریت پروژه، انجام شده است. این پروژه در قالب یک مخزن GitHub مدیریت می‌شود که از روش‌ Kanban برای پیگیری و انجام وظایف در آن استفاده شده است.

ساختار کلی پروژه:

پروژه شامل یک وب‌سایت ساده است که با استفاده از HTML و CSS پیاده‌سازی شده است. هر عضو تیم مسئولیت بخشی از پروژه را بر عهده گرفته و کارهای خود را با کمک ابزارهای Git و Kanban مدیریت کرده است.

برای مدیریت وظایف، از SE-Lab-HW1-Kanban در بخش پروژه‌های GitHub استفاده شده است. این Kanban به سه ستون اصلی تقسیم می‌شود که نشان‌دهنده وضعیت وظایف در مراحل مختلف پروژه است:

Ready: شامل وظایفی که هنوز شروع نشده‌اند

In Progress: وظایفی که اعضای تیم در حال کار بر روی آن‌ها هستند

Done: وظایفی که تکمیل شده و به پایان رسیده‌اند

ابتدا طراحی اولیه وب‌سایت با استفاده از HTML انجام شد. در این مرحله، ما ساختار اصلی وب‌سایت را مشخص کردیم و با تمرکز بر ایجاد صفحات اصلی، اسکلتی برای تمامی بخش‌های وب‌سایت ایجاد کردیم. هدف این مرحله فراهم آوردن یک پایه قوی بود تا اعضای تیم بتوانند با استایل‌دهی و تکمیل محتوای وب‌سایت به مرور آن را به شکل نهایی نزدیک کنند. HTML به عنوان زبانی ساده ولی کارآمد برای ساختاردهی صفحات وب به کار رفت و ما سعی کردیم از بهترین شیوه‌های نوین طراحی وب برای ساختاردهی صحیح و استاندارد استفاده کنیم.

یکی از بخش‌های اصلی پروژه، اضافه کردن نمودارها و گراف‌های آماری بود. این بخش با توجه به نیاز پروژه به نمایش داده‌های آماری در قالب بصری، یکی از مهم‌ترین بخش‌ها به شمار می‌رفت. ما ابتدا طرح اولیه‌ای برای نمودارها آماده کردیم و سپس با استفاده از CSS و JavaScript، نمودارها را به شکلی تعاملی و زیبا در صفحه پیاده‌سازی کردیم. این بخش از کار شامل چندین مرحله بهبود و اصلاح بود تا نمودارها به شکلی مطلوب نمایش داده شوند و تمامی جزئیات مورد نظر در آن‌ها لحاظ شوند.

در کنار طراحی و توسعه بصری، ما همچنین به بهینه‌سازی کدها و اطمینان از کارکرد صحیح بخش‌های مختلف وب‌سایت توجه ویژه‌ای داشتیم. یکی از چالش‌های اصلی ما در این مرحله، رفع تداخلات کد بود که به واسطه هم‌زمانی کار چندین عضو تیم ایجاد می‌شد. برای حل این مشکل، از بازبینی مداوم کدها و merge شاخه‌های مختلف استفاده کردیم. این فرآیند به ما کمک کرد تا تمامی تغییرات به‌صورت هماهنگ در پروژه اعمال شود و از وجود هرگونه اشکال یا ناسازگاری جلوگیری کنیم.

با پیشرفت پروژه، بخش‌های مختلفی به وب‌سایت اضافه شد. یکی از این بخش‌ها سیستم FAQ بود. این بخش با استفاده از انیمیشن‌های ساده و جذاب به شکلی تعاملی پیاده‌سازی شد تا تجربه کاربری را بهبود ببخشد. در اینجا، از تکنیک‌های CSS برای ایجاد انیمیشن‌های روان استفاده کردیم و با جاوااسکریپت تعاملات لازم را برای نمایش و مخفی کردن پاسخ‌ها فراهم کردیم.

پس از اتمام بخش‌های اصلی پروژه به بررسی و بهینه‌سازی نهایی پرداختیم. در این مرحله، کدها به دقت بازبینی شدند تا هرگونه باگ یا مشکل احتمالی شناسایی و رفع شود. همچنین، طراحی نهایی وب‌سایت از نظر عملکرد و سرعت بهینه‌سازی شد تا تجربه کاربری بهتری ارائه دهد. در این بازه، تلاش کردیم تا مطمئن شویم تمامی جزئیات پروژه به درستی پیاده‌سازی شده و هیچ‌گونه مشکلی در نسخه نهایی وجود ندارد.

در این تمرین، ما برای پیاده‌سازی بخش‌های مختلف پروژه از شاخه‌های مختلفی استفاده کردم. در مرحله آخر باید این شاخه‌ها را با هم merge می‌کردیم. در حین merge کردن با تعدادی conflict مواجه شدیم که با همفکری یکدیگر و بررسی کدهای هر شاخه، به حل آن‌ها پرداختیم.

در نهایت، با همکاری مداوم و استفاده از ابزارهای مدیریت پروژه، توانستیم پروژه SE-Lab-HW1 را با موفقیت به اتمام برسانیم. این تجربه برای ما فرصتی بود تا همزمان با یادگیری اصول طراحی و توسعه وب، مهارت‌های مدیریت پروژه و کار گروهی خود را نیز بهبود ببخشیم. استفاده از GitHub و Kanban نه تنها به ما کمک کرد تا وظایف را به‌صورت منظم پیگیری کنیم، بلکه همکاری ما را در تمام مراحل پروژه بهبود بخشید و اطمینان حاصل کردیم که تمامی اعضای تیم به شکلی هماهنگ و منسجم بر روی یک هدف مشترک کار می‌کنند.

# استقرار مستمر با استفاده از GitHub Actions

<p dir='rtl' align='right'>
با استفاده از workflowی آماده‌ی <a href="https://github.com/peaceiris/actions-gh-pages">actions-gh-pages</a>، توانستیم صفحه وبسایت استاتیک را که به صورت pure نوشته شده بود روی <a href="https://parjavadian.github.io/SE-Lab-HW1/">ادرس</a> مستقر کنیم. جزئیات استفاده از این workflow در فایل main.yml قابل مشاهده است.
 برای این منظور، تنظیمات مخزن را به شکل زیر تغییر دادیم تا استقرار از روی شاخهٔ main به صورت خودکار صورت گیرد.
  <img width="809" alt="Screenshot 2024-10-23 at 5 34 15 PM" src="https://github.com/user-attachments/assets/2b529cd6-fb87-46fd-b5f5-06745c9270e3">

</p>

# محافظت از شاخهٔ main

<p dir='rtl' align='right'>
با ایجاد یک rule جدید در بخش rulesets از تنظیمات مخزن و اعمال آن به شاخهٔ main، شاخهٔ main به نحوی محافظت شد که ادغام شاخه‌های دیگر با آن فقط از طریق pull request امکان‌پذیر باشد.

</p>
 
<img width="815" alt="Screenshot 2024-10-23 at 5 42 42 PM" src="https://github.com/user-attachments/assets/d5037a51-e8e8-44de-a5d6-e9e7eed7f577">





# پوشه‌ی .git چیست؟ چه اطلاعاتی در آن ذخیره می‌شود؟ با چه دستوری ساخته می‌شود؟

<p dir='rtl' align='right'>
پوشه‌ی .git دایرکتوری مخفی است که توسط Git برای مدیریت نسخه‌ها و اطلاعات مربوط به یک پروژه استفاده می‌شود. این پوشه حاوی اطلاعاتی همچون تاریخچه‌ی کامیت‌ها، شاخه‌ها، استیج (index)، تنظیمات محلی مخزن و دیگر داده‌های مرتبط با پروژه است. این پوشه با اجرای دستور زیر ساخته می‌شود:
</p>
<p>bash</p>
<p>Copy code </p>
<p>git init </p>
<p dir='rtl' align='right'>
این دستور یک مخزن Git جدید ایجاد می‌کند و پوشه‌ی .git را در مسیر پروژه قرار می‌دهد.
  
</p>

# منظور از atomic بودن در atomic commit و atomic pull-request چیست؟

<p dir='rtl' align='right'>
منظور از اتمیک این است که عملیات مورد نظر به صورت کامل و بدون تقسیم به بخش‌های کوچکتر انجام می‌شود، به طوری که یا همه‌ی تغییرات به صورت کامل اعمال شوند یا هیچ کدام از آن‌ها اعمال نشوند.

در atomic commit، مجموعه‌ای از تغییرات در یک کامیت اعمال می‌شود تا همه‌ی آن‌ها با هم ثبت شوند.
در atomic pull-request، مجموعه‌ای از تغییرات به طور کامل و یکجا به مخزن اصلی اضافه می‌شوند.

</p>

# تفاوت دستورهای fetch و pull و merge و rebase و cherry-pick

<p dir='rtl' align='right'>
fetch: این دستور تغییرات مخزن راه‌دور (remote) را دریافت می‌کند، ولی به مخزن محلی اضافه نمی‌کند.
  
pull: دستور pull، شامل fetch و merge است و تغییرات را از مخزن راه‌دور دریافت و به شاخه فعلی اضافه می‌کند.

merge: شاخه‌ای را با شاخه فعلی ترکیب می‌کند و تغییرات هر دو شاخه را در یک شاخه ادغام می‌کند.

rebase: تغییرات شاخه‌ی فعلی را روی یک شاخه‌ی دیگر اعمال می‌کند، به طوری که تاریخچه‌ی خطی‌تری داشته باشیم.

cherry-pick: یک کامیت خاص را از یک شاخه‌ی دیگر انتخاب و به شاخه فعلی اضافه می‌کند.

</p>

# تفاوت دستورهای reset و revert و restore و switch و checkout

reset: به تاریخچه‌ی یک شاخه بازگشته و تغییرات را به وضعیت قبلی برمی‌گرداند

revert: یک کامیت جدید ایجاد می‌کند که تغییرات یک کامیت مشخص را معکوس می‌کند

restore: فایل‌های تغییر یافته را به وضعیت قبلی بازمی‌گرداند

switch: برای تغییر شاخه‌ی فعلی به یک شاخه‌ی دیگر استفاده می‌شود

checkout: به منظور تغییر شاخه‌ی فعلی و همچنین بررسی و جابجایی بین نسخه‌های مختلف فایل‌ها استفاده می‌شود

# منظور از stage یا همان index چیست؟ دستور stash چه کاری را انجام می‌دهد؟

<p dir='rtl' align='right'>
stage یا index محلی موقت برای نگهداری تغییرات قبل از انجام کامیت است. تغییراتی که به مرحله‌ی stage اضافه می‌شوند، در کامیت بعدی ثبت می‌شوند.

stash: تغییرات فعلی که هنوز کامیت نشده‌اند را به طور موقت ذخیره کرده و وضعیت شاخه را به آخرین کامیت برمی‌گرداند

</p>

# مفهوم snapshot به چه معناست؟ ارتباط آن با commit چیست؟

<p dir='rtl' align='right'>
snapshot در Git به معنای تصویری از وضعیت پروژه در یک زمان خاص است. هر commit در واقع یک snapshot از فایل‌های پروژه است که به همراه تاریخچه و پیام مربوط به تغییرات ذخیره می‌شود.
</p>

# تفاوت‌های local repository و remote repository چیست؟

<p dir='rtl' align='right'>
local repository: مخزن محلی که روی سیستم شخصی کاربر قرار دارد و کاربر می‌تواند تغییرات را به آن اعمال کند.
remote repository: مخزن راه‌دور که معمولاً بر روی سرور قرار دارد و به اشتراک‌گذاری کد و همکاری بین چندین کاربر کمک می‌کند.
</p>
